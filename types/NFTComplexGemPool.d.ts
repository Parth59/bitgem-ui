/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface NFTComplexGemPoolInterface extends ethers.utils.Interface {
  functions: {
    "addAllowedToken(address)": FunctionFragment;
    "addAllowedTokenSource(address)": FunctionFragment;
    "addController(address)": FunctionFragment;
    "addInputRequirement(address,address,uint8,uint256,uint256,bool,bool)": FunctionFragment;
    "addLegacyToken(address,uint8,uint256,uint256,address,uint256)": FunctionFragment;
    "allInputRequirements(uint256)": FunctionFragment;
    "allInputRequirementsLength()": FunctionFragment;
    "allTokenHashes(uint256)": FunctionFragment;
    "allTokenHashesLength()": FunctionFragment;
    "allowPurchase()": FunctionFragment;
    "allowedTokenSources()": FunctionFragment;
    "allowedTokens(uint256)": FunctionFragment;
    "allowedTokensLength()": FunctionFragment;
    "category()": FunctionFragment;
    "claim(uint256)": FunctionFragment;
    "claimAmount(uint256)": FunctionFragment;
    "claimQuantity(uint256)": FunctionFragment;
    "claimTokenAmount(uint256)": FunctionFragment;
    "claimUnlockTime(uint256)": FunctionFragment;
    "claimedCount()": FunctionFragment;
    "collectClaim(uint256)": FunctionFragment;
    "createClaim(uint256)": FunctionFragment;
    "createClaims(uint256,uint256)": FunctionFragment;
    "createERC20Claim(address,uint256)": FunctionFragment;
    "createERC20Claims(address,uint256,uint256)": FunctionFragment;
    "deposit(address,uint256)": FunctionFragment;
    "depositNFT(address,uint256,uint256)": FunctionFragment;
    "description()": FunctionFragment;
    "enabled()": FunctionFragment;
    "ethPrice()": FunctionFragment;
    "gemClaimHash(uint256)": FunctionFragment;
    "initialize(string,string,uint256,uint256,uint256,uint256,uint256,address)": FunctionFragment;
    "isController(address)": FunctionFragment;
    "isTokenAllowed(address)": FunctionFragment;
    "maxClaimsPerAccount()": FunctionFragment;
    "maxQuantityPerClaim()": FunctionFragment;
    "mintGenesisGems(address,address)": FunctionFragment;
    "mintedCount()": FunctionFragment;
    "nextClaimHash()": FunctionFragment;
    "nextClaimId()": FunctionFragment;
    "nextGemHash()": FunctionFragment;
    "nextGemId()": FunctionFragment;
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "priceIncrementType()": FunctionFragment;
    "proxies(address)": FunctionFragment;
    "purchaseGems(uint256)": FunctionFragment;
    "relinquishControl()": FunctionFragment;
    "removeAllowedToken(address)": FunctionFragment;
    "removeAllowedTokenSource(address)": FunctionFragment;
    "setAllowPurchase(bool)": FunctionFragment;
    "setCategory(uint256)": FunctionFragment;
    "setDescription(string)": FunctionFragment;
    "setEnabled(bool)": FunctionFragment;
    "setFeeTracker(address)": FunctionFragment;
    "setGovernor(address)": FunctionFragment;
    "setMaxClaimsPerAccount(uint256)": FunctionFragment;
    "setMaxQuantityPerClaim(uint256)": FunctionFragment;
    "setMultiToken(address)": FunctionFragment;
    "setNextIds(uint256,uint256)": FunctionFragment;
    "setPriceIncrementType(uint8)": FunctionFragment;
    "setSwapHelper(address)": FunctionFragment;
    "setToken(uint256,uint8,uint256)": FunctionFragment;
    "setTokenHashes(uint256[])": FunctionFragment;
    "setValidateErc20(bool)": FunctionFragment;
    "setVisible(bool)": FunctionFragment;
    "settings()": FunctionFragment;
    "stakedToken(uint256)": FunctionFragment;
    "stats()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "symbol()": FunctionFragment;
    "token(uint256)": FunctionFragment;
    "tokenHashes()": FunctionFragment;
    "tokenId(uint256)": FunctionFragment;
    "tokenType(uint256)": FunctionFragment;
    "totalStakedEth()": FunctionFragment;
    "updateInputRequirement(uint256,address,address,uint8,uint256,uint256,bool,bool)": FunctionFragment;
    "validateErc20()": FunctionFragment;
    "visible()": FunctionFragment;
    "withdraw(address,address,uint256)": FunctionFragment;
    "withdrawNFT(address,address,uint256,uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "addAllowedToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "addAllowedTokenSource",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "addController",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "addInputRequirement",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addLegacyToken",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "allInputRequirements",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "allInputRequirementsLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allTokenHashes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "allTokenHashesLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allowPurchase",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allowedTokenSources",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allowedTokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "allowedTokensLength",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "category", values?: undefined): string;
  encodeFunctionData(functionFragment: "claim", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "claimAmount",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimQuantity",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimTokenAmount",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimUnlockTime",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimedCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "collectClaim",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createClaim",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createClaims",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createERC20Claim",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createERC20Claims",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "depositNFT",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "description",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "enabled", values?: undefined): string;
  encodeFunctionData(functionFragment: "ethPrice", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "gemClaimHash",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isController",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "isTokenAllowed",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "maxClaimsPerAccount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "maxQuantityPerClaim",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "mintGenesisGems",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "mintedCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextClaimHash",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextClaimId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextGemHash",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "nextGemId", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "priceIncrementType",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "proxies", values: [string]): string;
  encodeFunctionData(
    functionFragment: "purchaseGems",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "relinquishControl",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "removeAllowedToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeAllowedTokenSource",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setAllowPurchase",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setCategory",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setDescription",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "setEnabled", values: [boolean]): string;
  encodeFunctionData(
    functionFragment: "setFeeTracker",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "setGovernor", values: [string]): string;
  encodeFunctionData(
    functionFragment: "setMaxClaimsPerAccount",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxQuantityPerClaim",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setMultiToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setNextIds",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceIncrementType",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setSwapHelper",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setToken",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenHashes",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setValidateErc20",
    values: [boolean]
  ): string;
  encodeFunctionData(functionFragment: "setVisible", values: [boolean]): string;
  encodeFunctionData(functionFragment: "settings", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "stakedToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "stats", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(functionFragment: "token", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "tokenHashes",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenId",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenType",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "totalStakedEth",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateInputRequirement",
    values: [
      BigNumberish,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "validateErc20",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "visible", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawNFT",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "addAllowedToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addAllowedTokenSource",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addInputRequirement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLegacyToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allInputRequirements",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allInputRequirementsLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allTokenHashes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allTokenHashesLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allowPurchase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allowedTokenSources",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allowedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allowedTokensLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "category", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimQuantity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimTokenAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimUnlockTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimedCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collectClaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createClaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createClaims",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createERC20Claim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createERC20Claims",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "depositNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "description",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "enabled", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ethPrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "gemClaimHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTokenAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxClaimsPerAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxQuantityPerClaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintGenesisGems",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintedCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextClaimHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextClaimId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nextGemHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nextGemId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceIncrementType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "proxies", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "purchaseGems",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "relinquishControl",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeAllowedToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeAllowedTokenSource",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAllowPurchase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCategory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDescription",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setEnabled", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setFeeTracker",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setGovernor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxClaimsPerAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxQuantityPerClaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMultiToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setNextIds", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setPriceIncrementType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSwapHelper",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setTokenHashes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setValidateErc20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setVisible", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "settings", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakedToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stats", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "token", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenHashes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "tokenId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenType", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalStakedEth",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateInputRequirement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateErc20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "visible", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawNFT",
    data: BytesLike
  ): Result;

  events: {
    "NFTGemClaimCreated(address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "NFTGemClaimRedeemed(address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "NFTGemCreated(address,address,uint256,uint256,uint256)": EventFragment;
    "NFTGemERC20ClaimCreated(address,address,uint256,uint256,address,uint256,uint256)": EventFragment;
    "NFTGemERC20ClaimRedeemed(address,address,uint256,address,uint256,uint256,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "NFTGemClaimCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTGemClaimRedeemed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTGemCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTGemERC20ClaimCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTGemERC20ClaimRedeemed"): EventFragment;
}

export class NFTComplexGemPool extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: NFTComplexGemPoolInterface;

  functions: {
    addAllowedToken(
      tkn: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addAllowedToken(address)"(
      tkn: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addAllowedTokenSource(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addAllowedTokenSource(address)"(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addController(
      controller: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addController(address)"(
      controller: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addInputRequirement(
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addInputRequirement(address,address,uint8,uint256,uint256,bool,bool)"(
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addLegacyToken(
      token: string,
      tokenType: BigNumberish,
      tokenHash: BigNumberish,
      tokenId: BigNumberish,
      recipient: string,
      qty: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addLegacyToken(address,uint8,uint256,uint256,address,uint256)"(
      token: string,
      tokenType: BigNumberish,
      tokenHash: BigNumberish,
      tokenId: BigNumberish,
      recipient: string,
      qty: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    allInputRequirements(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, number, BigNumber, BigNumber, boolean, boolean]
    >;

    "allInputRequirements(uint256)"(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, number, BigNumber, BigNumber, boolean, boolean]
    >;

    allInputRequirementsLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    "allInputRequirementsLength()"(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    allTokenHashes(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "allTokenHashes(uint256)"(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    allTokenHashesLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    "allTokenHashesLength()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    allowPurchase(overrides?: CallOverrides): Promise<[boolean]>;

    "allowPurchase()"(overrides?: CallOverrides): Promise<[boolean]>;

    allowedTokenSources(overrides?: Overrides): Promise<ContractTransaction>;

    "allowedTokenSources()"(
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    allowedTokens(
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    "allowedTokens(uint256)"(
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    allowedTokensLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    "allowedTokensLength()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    category(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { c: BigNumber }>;

    "category()"(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { c: BigNumber }>;

    claim(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, string, BigNumber] & {
        claimAmount: BigNumber;
        claimQuantity: BigNumber;
        claimUnlockTime: BigNumber;
        claimTokenAmount: BigNumber;
        stakedToken: string;
        nextClaimId: BigNumber;
      }
    >;

    "claim(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, string, BigNumber] & {
        claimAmount: BigNumber;
        claimQuantity: BigNumber;
        claimUnlockTime: BigNumber;
        claimTokenAmount: BigNumber;
        stakedToken: string;
        nextClaimId: BigNumber;
      }
    >;

    claimAmount(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "claimAmount(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    claimQuantity(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "claimQuantity(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    claimTokenAmount(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "claimTokenAmount(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    claimUnlockTime(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "claimUnlockTime(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    claimedCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    "claimedCount()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    collectClaim(
      claimHash: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "collectClaim(uint256)"(
      claimHash: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    createClaim(
      timeframe: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "createClaim(uint256)"(
      timeframe: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    createClaims(
      timeframe: BigNumberish,
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "createClaims(uint256,uint256)"(
      timeframe: BigNumberish,
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    createERC20Claim(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "createERC20Claim(address,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    createERC20Claims(
      erc20token: string,
      tokenAmount: BigNumberish,
      count: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "createERC20Claims(address,uint256,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      count: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    deposit(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "deposit(address,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    depositNFT(
      erc1155token: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "depositNFT(address,uint256,uint256)"(
      erc1155token: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    description(overrides?: CallOverrides): Promise<[string] & { c: string }>;

    "description()"(
      overrides?: CallOverrides
    ): Promise<[string] & { c: string }>;

    enabled(overrides?: CallOverrides): Promise<[boolean]>;

    "enabled()"(overrides?: CallOverrides): Promise<[boolean]>;

    ethPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    "ethPrice()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    gemClaimHash(
      gemHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "gemClaimHash(uint256)"(
      gemHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    initialize(
      __symbol: string,
      __name: string,
      __ethPrice: BigNumberish,
      __minTime: BigNumberish,
      __maxTime: BigNumberish,
      __diffstep: BigNumberish,
      __maxClaims: BigNumberish,
      __allowedToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "initialize(string,string,uint256,uint256,uint256,uint256,uint256,address)"(
      __symbol: string,
      __name: string,
      __ethPrice: BigNumberish,
      __minTime: BigNumberish,
      __maxTime: BigNumberish,
      __diffstep: BigNumberish,
      __maxClaims: BigNumberish,
      __allowedToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    isController(
      caddress: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    "isController(address)"(
      caddress: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTokenAllowed(tkn: string, overrides?: CallOverrides): Promise<[boolean]>;

    "isTokenAllowed(address)"(
      tkn: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    maxClaimsPerAccount(overrides?: CallOverrides): Promise<[BigNumber]>;

    "maxClaimsPerAccount()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    maxQuantityPerClaim(overrides?: CallOverrides): Promise<[BigNumber]>;

    "maxQuantityPerClaim()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    mintGenesisGems(
      creator: string,
      funder: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "mintGenesisGems(address,address)"(
      creator: string,
      funder: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    mintedCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    "mintedCount()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextClaimHash(overrides?: CallOverrides): Promise<[BigNumber]>;

    "nextClaimHash()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextClaimId(overrides?: CallOverrides): Promise<[BigNumber]>;

    "nextClaimId()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextGemHash(overrides?: CallOverrides): Promise<[BigNumber]>;

    "nextGemHash()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    nextGemId(overrides?: CallOverrides): Promise<[BigNumber]>;

    "nextGemId()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    onERC1155BatchReceived(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    priceIncrementType(overrides?: CallOverrides): Promise<[number]>;

    "priceIncrementType()"(overrides?: CallOverrides): Promise<[number]>;

    proxies(arg0: string, overrides?: CallOverrides): Promise<[string]>;

    "proxies(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    purchaseGems(
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    "purchaseGems(uint256)"(
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    relinquishControl(overrides?: Overrides): Promise<ContractTransaction>;

    "relinquishControl()"(overrides?: Overrides): Promise<ContractTransaction>;

    removeAllowedToken(
      tkn: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeAllowedToken(address)"(
      tkn: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removeAllowedTokenSource(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeAllowedTokenSource(address)"(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setAllowPurchase(
      allow: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setAllowPurchase(bool)"(
      allow: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setCategory(
      category: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setCategory(uint256)"(
      category: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setDescription(
      desc: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setDescription(string)"(
      desc: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setEnabled(
      enable: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setEnabled(bool)"(
      enable: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setFeeTracker(
      addr: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setFeeTracker(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setGovernor(
      addr: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setGovernor(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setMaxClaimsPerAccount(
      maxCPA: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setMaxClaimsPerAccount(uint256)"(
      maxCPA: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setMaxQuantityPerClaim(
      maxQty: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setMaxQuantityPerClaim(uint256)"(
      maxQty: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setMultiToken(
      addr: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setMultiToken(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setNextIds(
      nextClaimId: BigNumberish,
      nextGemId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setNextIds(uint256,uint256)"(
      nextClaimId: BigNumberish,
      nextGemId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setPriceIncrementType(
      incrementType: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setPriceIncrementType(uint8)"(
      incrementType: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setSwapHelper(
      addr: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setSwapHelper(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setToken(
      tokenHash: BigNumberish,
      tokenType: BigNumberish,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setToken(uint256,uint8,uint256)"(
      tokenHash: BigNumberish,
      tokenType: BigNumberish,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setTokenHashes(
      tokenHashes: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setTokenHashes(uint256[])"(
      tokenHashes: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setValidateErc20(
      arg0: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setValidateErc20(bool)"(
      arg0: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    setVisible(
      visible: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setVisible(bool)"(
      visible: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    settings(
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        symbol: string;
        name: string;
        description: string;
        category: BigNumber;
        ethPrice: BigNumber;
        minTime: BigNumber;
        maxTime: BigNumber;
        diffstep: BigNumber;
        maxClaims: BigNumber;
        maxQuantityPerClaim: BigNumber;
        maxClaimsPerAccount: BigNumber;
      }
    >;

    "settings()"(
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        symbol: string;
        name: string;
        description: string;
        category: BigNumber;
        ethPrice: BigNumber;
        minTime: BigNumber;
        maxTime: BigNumber;
        diffstep: BigNumber;
        maxClaims: BigNumber;
        maxQuantityPerClaim: BigNumber;
        maxClaimsPerAccount: BigNumber;
      }
    >;

    stakedToken(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    "stakedToken(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    stats(
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        visible: boolean;
        claimedCount: BigNumber;
        mintedCount: BigNumber;
        totalStakedEth: BigNumber;
        nextClaimHash: BigNumber;
        nextGemHash: BigNumber;
        nextClaimId: BigNumber;
        nextGemId: BigNumber;
      }
    >;

    "stats()"(
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        visible: boolean;
        claimedCount: BigNumber;
        mintedCount: BigNumber;
        totalStakedEth: BigNumber;
        nextClaimHash: BigNumber;
        nextGemHash: BigNumber;
        nextClaimId: BigNumber;
        nextGemId: BigNumber;
      }
    >;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    "supportsInterface(bytes4)"(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    "symbol()"(overrides?: CallOverrides): Promise<[string]>;

    token(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, string] & {
        tokenType: number;
        tokenId: BigNumber;
        tokenSource: string;
      }
    >;

    "token(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, string] & {
        tokenType: number;
        tokenId: BigNumber;
        tokenSource: string;
      }
    >;

    tokenHashes(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    "tokenHashes()"(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    tokenId(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "tokenId(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    tokenType(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number]>;

    "tokenType(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number]>;

    totalStakedEth(overrides?: CallOverrides): Promise<[BigNumber]>;

    "totalStakedEth()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    updateInputRequirement(
      ndx: BigNumberish,
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "updateInputRequirement(uint256,address,address,uint8,uint256,uint256,bool,bool)"(
      ndx: BigNumberish,
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    validateErc20(overrides?: CallOverrides): Promise<[boolean]>;

    "validateErc20()"(overrides?: CallOverrides): Promise<[boolean]>;

    visible(overrides?: CallOverrides): Promise<[boolean] & { v: boolean }>;

    "visible()"(overrides?: CallOverrides): Promise<[boolean] & { v: boolean }>;

    withdraw(
      erc20token: string,
      destination: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "withdraw(address,address,uint256)"(
      erc20token: string,
      destination: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    withdrawNFT(
      erc1155token: string,
      destination: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "withdrawNFT(address,address,uint256,uint256)"(
      erc1155token: string,
      destination: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  addAllowedToken(
    tkn: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addAllowedToken(address)"(
    tkn: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addAllowedTokenSource(
    allowedToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addAllowedTokenSource(address)"(
    allowedToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addController(
    controller: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addController(address)"(
    controller: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addInputRequirement(
    token: string,
    pool: string,
    inputType: BigNumberish,
    tid: BigNumberish,
    minAmount: BigNumberish,
    takeCustody: boolean,
    burn: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addInputRequirement(address,address,uint8,uint256,uint256,bool,bool)"(
    token: string,
    pool: string,
    inputType: BigNumberish,
    tid: BigNumberish,
    minAmount: BigNumberish,
    takeCustody: boolean,
    burn: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addLegacyToken(
    token: string,
    tokenType: BigNumberish,
    tokenHash: BigNumberish,
    tokenId: BigNumberish,
    recipient: string,
    qty: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addLegacyToken(address,uint8,uint256,uint256,address,uint256)"(
    token: string,
    tokenType: BigNumberish,
    tokenHash: BigNumberish,
    tokenId: BigNumberish,
    recipient: string,
    qty: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  allInputRequirements(
    ndx: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, string, number, BigNumber, BigNumber, boolean, boolean]>;

  "allInputRequirements(uint256)"(
    ndx: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, string, number, BigNumber, BigNumber, boolean, boolean]>;

  allInputRequirementsLength(overrides?: CallOverrides): Promise<BigNumber>;

  "allInputRequirementsLength()"(overrides?: CallOverrides): Promise<BigNumber>;

  allTokenHashes(
    ndx: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "allTokenHashes(uint256)"(
    ndx: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  allTokenHashesLength(overrides?: CallOverrides): Promise<BigNumber>;

  "allTokenHashesLength()"(overrides?: CallOverrides): Promise<BigNumber>;

  allowPurchase(overrides?: CallOverrides): Promise<boolean>;

  "allowPurchase()"(overrides?: CallOverrides): Promise<boolean>;

  allowedTokenSources(overrides?: Overrides): Promise<ContractTransaction>;

  "allowedTokenSources()"(overrides?: Overrides): Promise<ContractTransaction>;

  allowedTokens(idx: BigNumberish, overrides?: CallOverrides): Promise<string>;

  "allowedTokens(uint256)"(
    idx: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  allowedTokensLength(overrides?: CallOverrides): Promise<BigNumber>;

  "allowedTokensLength()"(overrides?: CallOverrides): Promise<BigNumber>;

  category(overrides?: CallOverrides): Promise<BigNumber>;

  "category()"(overrides?: CallOverrides): Promise<BigNumber>;

  claim(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, string, BigNumber] & {
      claimAmount: BigNumber;
      claimQuantity: BigNumber;
      claimUnlockTime: BigNumber;
      claimTokenAmount: BigNumber;
      stakedToken: string;
      nextClaimId: BigNumber;
    }
  >;

  "claim(uint256)"(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, string, BigNumber] & {
      claimAmount: BigNumber;
      claimQuantity: BigNumber;
      claimUnlockTime: BigNumber;
      claimTokenAmount: BigNumber;
      stakedToken: string;
      nextClaimId: BigNumber;
    }
  >;

  claimAmount(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "claimAmount(uint256)"(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimQuantity(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "claimQuantity(uint256)"(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimTokenAmount(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "claimTokenAmount(uint256)"(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimUnlockTime(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "claimUnlockTime(uint256)"(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimedCount(overrides?: CallOverrides): Promise<BigNumber>;

  "claimedCount()"(overrides?: CallOverrides): Promise<BigNumber>;

  collectClaim(
    claimHash: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "collectClaim(uint256)"(
    claimHash: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  createClaim(
    timeframe: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "createClaim(uint256)"(
    timeframe: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  createClaims(
    timeframe: BigNumberish,
    count: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "createClaims(uint256,uint256)"(
    timeframe: BigNumberish,
    count: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  createERC20Claim(
    erc20token: string,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "createERC20Claim(address,uint256)"(
    erc20token: string,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  createERC20Claims(
    erc20token: string,
    tokenAmount: BigNumberish,
    count: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "createERC20Claims(address,uint256,uint256)"(
    erc20token: string,
    tokenAmount: BigNumberish,
    count: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  deposit(
    erc20token: string,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "deposit(address,uint256)"(
    erc20token: string,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  depositNFT(
    erc1155token: string,
    tokenId: BigNumberish,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "depositNFT(address,uint256,uint256)"(
    erc1155token: string,
    tokenId: BigNumberish,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  description(overrides?: CallOverrides): Promise<string>;

  "description()"(overrides?: CallOverrides): Promise<string>;

  enabled(overrides?: CallOverrides): Promise<boolean>;

  "enabled()"(overrides?: CallOverrides): Promise<boolean>;

  ethPrice(overrides?: CallOverrides): Promise<BigNumber>;

  "ethPrice()"(overrides?: CallOverrides): Promise<BigNumber>;

  gemClaimHash(
    gemHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "gemClaimHash(uint256)"(
    gemHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initialize(
    __symbol: string,
    __name: string,
    __ethPrice: BigNumberish,
    __minTime: BigNumberish,
    __maxTime: BigNumberish,
    __diffstep: BigNumberish,
    __maxClaims: BigNumberish,
    __allowedToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "initialize(string,string,uint256,uint256,uint256,uint256,uint256,address)"(
    __symbol: string,
    __name: string,
    __ethPrice: BigNumberish,
    __minTime: BigNumberish,
    __maxTime: BigNumberish,
    __diffstep: BigNumberish,
    __maxClaims: BigNumberish,
    __allowedToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  isController(caddress: string, overrides?: CallOverrides): Promise<boolean>;

  "isController(address)"(
    caddress: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTokenAllowed(tkn: string, overrides?: CallOverrides): Promise<boolean>;

  "isTokenAllowed(address)"(
    tkn: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  maxClaimsPerAccount(overrides?: CallOverrides): Promise<BigNumber>;

  "maxClaimsPerAccount()"(overrides?: CallOverrides): Promise<BigNumber>;

  maxQuantityPerClaim(overrides?: CallOverrides): Promise<BigNumber>;

  "maxQuantityPerClaim()"(overrides?: CallOverrides): Promise<BigNumber>;

  mintGenesisGems(
    creator: string,
    funder: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "mintGenesisGems(address,address)"(
    creator: string,
    funder: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  mintedCount(overrides?: CallOverrides): Promise<BigNumber>;

  "mintedCount()"(overrides?: CallOverrides): Promise<BigNumber>;

  nextClaimHash(overrides?: CallOverrides): Promise<BigNumber>;

  "nextClaimHash()"(overrides?: CallOverrides): Promise<BigNumber>;

  nextClaimId(overrides?: CallOverrides): Promise<BigNumber>;

  "nextClaimId()"(overrides?: CallOverrides): Promise<BigNumber>;

  nextGemHash(overrides?: CallOverrides): Promise<BigNumber>;

  "nextGemHash()"(overrides?: CallOverrides): Promise<BigNumber>;

  nextGemId(overrides?: CallOverrides): Promise<BigNumber>;

  "nextGemId()"(overrides?: CallOverrides): Promise<BigNumber>;

  onERC1155BatchReceived(
    arg0: string,
    arg1: string,
    arg2: BigNumberish[],
    arg3: BigNumberish[],
    arg4: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
    arg0: string,
    arg1: string,
    arg2: BigNumberish[],
    arg3: BigNumberish[],
    arg4: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  onERC1155Received(
    arg0: string,
    arg1: string,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "onERC1155Received(address,address,uint256,uint256,bytes)"(
    arg0: string,
    arg1: string,
    arg2: BigNumberish,
    arg3: BigNumberish,
    arg4: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  priceIncrementType(overrides?: CallOverrides): Promise<number>;

  "priceIncrementType()"(overrides?: CallOverrides): Promise<number>;

  proxies(arg0: string, overrides?: CallOverrides): Promise<string>;

  "proxies(address)"(arg0: string, overrides?: CallOverrides): Promise<string>;

  purchaseGems(
    count: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  "purchaseGems(uint256)"(
    count: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  relinquishControl(overrides?: Overrides): Promise<ContractTransaction>;

  "relinquishControl()"(overrides?: Overrides): Promise<ContractTransaction>;

  removeAllowedToken(
    tkn: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeAllowedToken(address)"(
    tkn: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removeAllowedTokenSource(
    allowedToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeAllowedTokenSource(address)"(
    allowedToken: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setAllowPurchase(
    allow: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setAllowPurchase(bool)"(
    allow: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setCategory(
    category: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setCategory(uint256)"(
    category: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setDescription(
    desc: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setDescription(string)"(
    desc: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setEnabled(
    enable: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setEnabled(bool)"(
    enable: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setFeeTracker(
    addr: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setFeeTracker(address)"(
    addr: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setGovernor(
    addr: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setGovernor(address)"(
    addr: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setMaxClaimsPerAccount(
    maxCPA: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setMaxClaimsPerAccount(uint256)"(
    maxCPA: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setMaxQuantityPerClaim(
    maxQty: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setMaxQuantityPerClaim(uint256)"(
    maxQty: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setMultiToken(
    addr: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setMultiToken(address)"(
    addr: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setNextIds(
    nextClaimId: BigNumberish,
    nextGemId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setNextIds(uint256,uint256)"(
    nextClaimId: BigNumberish,
    nextGemId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setPriceIncrementType(
    incrementType: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setPriceIncrementType(uint8)"(
    incrementType: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setSwapHelper(
    addr: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setSwapHelper(address)"(
    addr: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setToken(
    tokenHash: BigNumberish,
    tokenType: BigNumberish,
    tokenId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setToken(uint256,uint8,uint256)"(
    tokenHash: BigNumberish,
    tokenType: BigNumberish,
    tokenId: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setTokenHashes(
    tokenHashes: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setTokenHashes(uint256[])"(
    tokenHashes: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setValidateErc20(
    arg0: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setValidateErc20(bool)"(
    arg0: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  setVisible(
    visible: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setVisible(bool)"(
    visible: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  settings(
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      symbol: string;
      name: string;
      description: string;
      category: BigNumber;
      ethPrice: BigNumber;
      minTime: BigNumber;
      maxTime: BigNumber;
      diffstep: BigNumber;
      maxClaims: BigNumber;
      maxQuantityPerClaim: BigNumber;
      maxClaimsPerAccount: BigNumber;
    }
  >;

  "settings()"(
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      symbol: string;
      name: string;
      description: string;
      category: BigNumber;
      ethPrice: BigNumber;
      minTime: BigNumber;
      maxTime: BigNumber;
      diffstep: BigNumber;
      maxClaims: BigNumber;
      maxQuantityPerClaim: BigNumber;
      maxClaimsPerAccount: BigNumber;
    }
  >;

  stakedToken(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  "stakedToken(uint256)"(
    claimHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  stats(
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      visible: boolean;
      claimedCount: BigNumber;
      mintedCount: BigNumber;
      totalStakedEth: BigNumber;
      nextClaimHash: BigNumber;
      nextGemHash: BigNumber;
      nextClaimId: BigNumber;
      nextGemId: BigNumber;
    }
  >;

  "stats()"(
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      visible: boolean;
      claimedCount: BigNumber;
      mintedCount: BigNumber;
      totalStakedEth: BigNumber;
      nextClaimHash: BigNumber;
      nextGemHash: BigNumber;
      nextClaimId: BigNumber;
      nextGemId: BigNumber;
    }
  >;

  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "supportsInterface(bytes4)"(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  symbol(overrides?: CallOverrides): Promise<string>;

  "symbol()"(overrides?: CallOverrides): Promise<string>;

  token(
    tokenHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, string] & {
      tokenType: number;
      tokenId: BigNumber;
      tokenSource: string;
    }
  >;

  "token(uint256)"(
    tokenHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, string] & {
      tokenType: number;
      tokenId: BigNumber;
      tokenSource: string;
    }
  >;

  tokenHashes(overrides?: CallOverrides): Promise<BigNumber[]>;

  "tokenHashes()"(overrides?: CallOverrides): Promise<BigNumber[]>;

  tokenId(
    tokenHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "tokenId(uint256)"(
    tokenHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tokenType(
    tokenHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<number>;

  "tokenType(uint256)"(
    tokenHash: BigNumberish,
    overrides?: CallOverrides
  ): Promise<number>;

  totalStakedEth(overrides?: CallOverrides): Promise<BigNumber>;

  "totalStakedEth()"(overrides?: CallOverrides): Promise<BigNumber>;

  updateInputRequirement(
    ndx: BigNumberish,
    token: string,
    pool: string,
    inputType: BigNumberish,
    tid: BigNumberish,
    minAmount: BigNumberish,
    takeCustody: boolean,
    burn: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "updateInputRequirement(uint256,address,address,uint8,uint256,uint256,bool,bool)"(
    ndx: BigNumberish,
    token: string,
    pool: string,
    inputType: BigNumberish,
    tid: BigNumberish,
    minAmount: BigNumberish,
    takeCustody: boolean,
    burn: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  validateErc20(overrides?: CallOverrides): Promise<boolean>;

  "validateErc20()"(overrides?: CallOverrides): Promise<boolean>;

  visible(overrides?: CallOverrides): Promise<boolean>;

  "visible()"(overrides?: CallOverrides): Promise<boolean>;

  withdraw(
    erc20token: string,
    destination: string,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "withdraw(address,address,uint256)"(
    erc20token: string,
    destination: string,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  withdrawNFT(
    erc1155token: string,
    destination: string,
    tokenId: BigNumberish,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "withdrawNFT(address,address,uint256,uint256)"(
    erc1155token: string,
    destination: string,
    tokenId: BigNumberish,
    tokenAmount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    addAllowedToken(tkn: string, overrides?: CallOverrides): Promise<void>;

    "addAllowedToken(address)"(
      tkn: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addAllowedTokenSource(
      allowedToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "addAllowedTokenSource(address)"(
      allowedToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addController(controller: string, overrides?: CallOverrides): Promise<void>;

    "addController(address)"(
      controller: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addInputRequirement(
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    "addInputRequirement(address,address,uint8,uint256,uint256,bool,bool)"(
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    addLegacyToken(
      token: string,
      tokenType: BigNumberish,
      tokenHash: BigNumberish,
      tokenId: BigNumberish,
      recipient: string,
      qty: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "addLegacyToken(address,uint8,uint256,uint256,address,uint256)"(
      token: string,
      tokenType: BigNumberish,
      tokenHash: BigNumberish,
      tokenId: BigNumberish,
      recipient: string,
      qty: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    allInputRequirements(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, number, BigNumber, BigNumber, boolean, boolean]
    >;

    "allInputRequirements(uint256)"(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, number, BigNumber, BigNumber, boolean, boolean]
    >;

    allInputRequirementsLength(overrides?: CallOverrides): Promise<BigNumber>;

    "allInputRequirementsLength()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allTokenHashes(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "allTokenHashes(uint256)"(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allTokenHashesLength(overrides?: CallOverrides): Promise<BigNumber>;

    "allTokenHashesLength()"(overrides?: CallOverrides): Promise<BigNumber>;

    allowPurchase(overrides?: CallOverrides): Promise<boolean>;

    "allowPurchase()"(overrides?: CallOverrides): Promise<boolean>;

    allowedTokenSources(overrides?: CallOverrides): Promise<string[]>;

    "allowedTokenSources()"(overrides?: CallOverrides): Promise<string[]>;

    allowedTokens(
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    "allowedTokens(uint256)"(
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    allowedTokensLength(overrides?: CallOverrides): Promise<BigNumber>;

    "allowedTokensLength()"(overrides?: CallOverrides): Promise<BigNumber>;

    category(overrides?: CallOverrides): Promise<BigNumber>;

    "category()"(overrides?: CallOverrides): Promise<BigNumber>;

    claim(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, string, BigNumber] & {
        claimAmount: BigNumber;
        claimQuantity: BigNumber;
        claimUnlockTime: BigNumber;
        claimTokenAmount: BigNumber;
        stakedToken: string;
        nextClaimId: BigNumber;
      }
    >;

    "claim(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, string, BigNumber] & {
        claimAmount: BigNumber;
        claimQuantity: BigNumber;
        claimUnlockTime: BigNumber;
        claimTokenAmount: BigNumber;
        stakedToken: string;
        nextClaimId: BigNumber;
      }
    >;

    claimAmount(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimAmount(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimQuantity(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimQuantity(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimTokenAmount(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimTokenAmount(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimUnlockTime(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimUnlockTime(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimedCount(overrides?: CallOverrides): Promise<BigNumber>;

    "claimedCount()"(overrides?: CallOverrides): Promise<BigNumber>;

    collectClaim(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "collectClaim(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    createClaim(
      timeframe: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "createClaim(uint256)"(
      timeframe: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    createClaims(
      timeframe: BigNumberish,
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "createClaims(uint256,uint256)"(
      timeframe: BigNumberish,
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    createERC20Claim(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "createERC20Claim(address,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    createERC20Claims(
      erc20token: string,
      tokenAmount: BigNumberish,
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "createERC20Claims(address,uint256,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    deposit(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "deposit(address,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    depositNFT(
      erc1155token: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "depositNFT(address,uint256,uint256)"(
      erc1155token: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    description(overrides?: CallOverrides): Promise<string>;

    "description()"(overrides?: CallOverrides): Promise<string>;

    enabled(overrides?: CallOverrides): Promise<boolean>;

    "enabled()"(overrides?: CallOverrides): Promise<boolean>;

    ethPrice(overrides?: CallOverrides): Promise<BigNumber>;

    "ethPrice()"(overrides?: CallOverrides): Promise<BigNumber>;

    gemClaimHash(
      gemHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "gemClaimHash(uint256)"(
      gemHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      __symbol: string,
      __name: string,
      __ethPrice: BigNumberish,
      __minTime: BigNumberish,
      __maxTime: BigNumberish,
      __diffstep: BigNumberish,
      __maxClaims: BigNumberish,
      __allowedToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "initialize(string,string,uint256,uint256,uint256,uint256,uint256,address)"(
      __symbol: string,
      __name: string,
      __ethPrice: BigNumberish,
      __minTime: BigNumberish,
      __maxTime: BigNumberish,
      __diffstep: BigNumberish,
      __maxClaims: BigNumberish,
      __allowedToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    isController(caddress: string, overrides?: CallOverrides): Promise<boolean>;

    "isController(address)"(
      caddress: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTokenAllowed(tkn: string, overrides?: CallOverrides): Promise<boolean>;

    "isTokenAllowed(address)"(
      tkn: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    maxClaimsPerAccount(overrides?: CallOverrides): Promise<BigNumber>;

    "maxClaimsPerAccount()"(overrides?: CallOverrides): Promise<BigNumber>;

    maxQuantityPerClaim(overrides?: CallOverrides): Promise<BigNumber>;

    "maxQuantityPerClaim()"(overrides?: CallOverrides): Promise<BigNumber>;

    mintGenesisGems(
      creator: string,
      funder: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "mintGenesisGems(address,address)"(
      creator: string,
      funder: string,
      overrides?: CallOverrides
    ): Promise<void>;

    mintedCount(overrides?: CallOverrides): Promise<BigNumber>;

    "mintedCount()"(overrides?: CallOverrides): Promise<BigNumber>;

    nextClaimHash(overrides?: CallOverrides): Promise<BigNumber>;

    "nextClaimHash()"(overrides?: CallOverrides): Promise<BigNumber>;

    nextClaimId(overrides?: CallOverrides): Promise<BigNumber>;

    "nextClaimId()"(overrides?: CallOverrides): Promise<BigNumber>;

    nextGemHash(overrides?: CallOverrides): Promise<BigNumber>;

    "nextGemHash()"(overrides?: CallOverrides): Promise<BigNumber>;

    nextGemId(overrides?: CallOverrides): Promise<BigNumber>;

    "nextGemId()"(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    priceIncrementType(overrides?: CallOverrides): Promise<number>;

    "priceIncrementType()"(overrides?: CallOverrides): Promise<number>;

    proxies(arg0: string, overrides?: CallOverrides): Promise<string>;

    "proxies(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<string>;

    purchaseGems(count: BigNumberish, overrides?: CallOverrides): Promise<void>;

    "purchaseGems(uint256)"(
      count: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    relinquishControl(overrides?: CallOverrides): Promise<void>;

    "relinquishControl()"(overrides?: CallOverrides): Promise<void>;

    removeAllowedToken(tkn: string, overrides?: CallOverrides): Promise<void>;

    "removeAllowedToken(address)"(
      tkn: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeAllowedTokenSource(
      allowedToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "removeAllowedTokenSource(address)"(
      allowedToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setAllowPurchase(allow: boolean, overrides?: CallOverrides): Promise<void>;

    "setAllowPurchase(bool)"(
      allow: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setCategory(
      category: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "setCategory(uint256)"(
      category: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setDescription(desc: string, overrides?: CallOverrides): Promise<void>;

    "setDescription(string)"(
      desc: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setEnabled(enable: boolean, overrides?: CallOverrides): Promise<void>;

    "setEnabled(bool)"(
      enable: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setFeeTracker(addr: string, overrides?: CallOverrides): Promise<void>;

    "setFeeTracker(address)"(
      addr: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setGovernor(addr: string, overrides?: CallOverrides): Promise<void>;

    "setGovernor(address)"(
      addr: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxClaimsPerAccount(
      maxCPA: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "setMaxClaimsPerAccount(uint256)"(
      maxCPA: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxQuantityPerClaim(
      maxQty: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "setMaxQuantityPerClaim(uint256)"(
      maxQty: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setMultiToken(addr: string, overrides?: CallOverrides): Promise<void>;

    "setMultiToken(address)"(
      addr: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setNextIds(
      nextClaimId: BigNumberish,
      nextGemId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "setNextIds(uint256,uint256)"(
      nextClaimId: BigNumberish,
      nextGemId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setPriceIncrementType(
      incrementType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "setPriceIncrementType(uint8)"(
      incrementType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setSwapHelper(addr: string, overrides?: CallOverrides): Promise<void>;

    "setSwapHelper(address)"(
      addr: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setToken(
      tokenHash: BigNumberish,
      tokenType: BigNumberish,
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "setToken(uint256,uint8,uint256)"(
      tokenHash: BigNumberish,
      tokenType: BigNumberish,
      tokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setTokenHashes(
      tokenHashes: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    "setTokenHashes(uint256[])"(
      tokenHashes: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    setValidateErc20(arg0: boolean, overrides?: CallOverrides): Promise<void>;

    "setValidateErc20(bool)"(
      arg0: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setVisible(visible: boolean, overrides?: CallOverrides): Promise<void>;

    "setVisible(bool)"(
      visible: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    settings(
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        symbol: string;
        name: string;
        description: string;
        category: BigNumber;
        ethPrice: BigNumber;
        minTime: BigNumber;
        maxTime: BigNumber;
        diffstep: BigNumber;
        maxClaims: BigNumber;
        maxQuantityPerClaim: BigNumber;
        maxClaimsPerAccount: BigNumber;
      }
    >;

    "settings()"(
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        symbol: string;
        name: string;
        description: string;
        category: BigNumber;
        ethPrice: BigNumber;
        minTime: BigNumber;
        maxTime: BigNumber;
        diffstep: BigNumber;
        maxClaims: BigNumber;
        maxQuantityPerClaim: BigNumber;
        maxClaimsPerAccount: BigNumber;
      }
    >;

    stakedToken(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    "stakedToken(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    stats(
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        visible: boolean;
        claimedCount: BigNumber;
        mintedCount: BigNumber;
        totalStakedEth: BigNumber;
        nextClaimHash: BigNumber;
        nextGemHash: BigNumber;
        nextClaimId: BigNumber;
        nextGemId: BigNumber;
      }
    >;

    "stats()"(
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        visible: boolean;
        claimedCount: BigNumber;
        mintedCount: BigNumber;
        totalStakedEth: BigNumber;
        nextClaimHash: BigNumber;
        nextGemHash: BigNumber;
        nextClaimId: BigNumber;
        nextGemId: BigNumber;
      }
    >;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "supportsInterface(bytes4)"(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    symbol(overrides?: CallOverrides): Promise<string>;

    "symbol()"(overrides?: CallOverrides): Promise<string>;

    token(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, string] & {
        tokenType: number;
        tokenId: BigNumber;
        tokenSource: string;
      }
    >;

    "token(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, string] & {
        tokenType: number;
        tokenId: BigNumber;
        tokenSource: string;
      }
    >;

    tokenHashes(overrides?: CallOverrides): Promise<BigNumber[]>;

    "tokenHashes()"(overrides?: CallOverrides): Promise<BigNumber[]>;

    tokenId(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "tokenId(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenType(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    "tokenType(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    totalStakedEth(overrides?: CallOverrides): Promise<BigNumber>;

    "totalStakedEth()"(overrides?: CallOverrides): Promise<BigNumber>;

    updateInputRequirement(
      ndx: BigNumberish,
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    "updateInputRequirement(uint256,address,address,uint8,uint256,uint256,bool,bool)"(
      ndx: BigNumberish,
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    validateErc20(overrides?: CallOverrides): Promise<boolean>;

    "validateErc20()"(overrides?: CallOverrides): Promise<boolean>;

    visible(overrides?: CallOverrides): Promise<boolean>;

    "visible()"(overrides?: CallOverrides): Promise<boolean>;

    withdraw(
      erc20token: string,
      destination: string,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "withdraw(address,address,uint256)"(
      erc20token: string,
      destination: string,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawNFT(
      erc1155token: string,
      destination: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "withdrawNFT(address,address,uint256,uint256)"(
      erc1155token: string,
      destination: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    NFTGemClaimCreated(
      account: null,
      pool: null,
      claimHash: null,
      length: null,
      quantity: null,
      amountPaid: null
    ): EventFilter;

    NFTGemClaimRedeemed(
      account: null,
      pool: null,
      claimHash: null,
      amountPaid: null,
      quantity: null,
      feeAssessed: null
    ): EventFilter;

    NFTGemCreated(
      account: null,
      pool: null,
      claimHash: null,
      gemHash: null,
      quantity: null
    ): EventFilter;

    NFTGemERC20ClaimCreated(
      account: null,
      pool: null,
      claimHash: null,
      length: null,
      token: null,
      quantity: null,
      conversionRate: null
    ): EventFilter;

    NFTGemERC20ClaimRedeemed(
      account: null,
      pool: null,
      claimHash: null,
      token: null,
      ethPrice: null,
      tokenAmount: null,
      quantity: null,
      feeAssessed: null
    ): EventFilter;
  };

  estimateGas: {
    addAllowedToken(tkn: string, overrides?: Overrides): Promise<BigNumber>;

    "addAllowedToken(address)"(
      tkn: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addAllowedTokenSource(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addAllowedTokenSource(address)"(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addController(
      controller: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addController(address)"(
      controller: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addInputRequirement(
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addInputRequirement(address,address,uint8,uint256,uint256,bool,bool)"(
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addLegacyToken(
      token: string,
      tokenType: BigNumberish,
      tokenHash: BigNumberish,
      tokenId: BigNumberish,
      recipient: string,
      qty: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addLegacyToken(address,uint8,uint256,uint256,address,uint256)"(
      token: string,
      tokenType: BigNumberish,
      tokenHash: BigNumberish,
      tokenId: BigNumberish,
      recipient: string,
      qty: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    allInputRequirements(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "allInputRequirements(uint256)"(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allInputRequirementsLength(overrides?: CallOverrides): Promise<BigNumber>;

    "allInputRequirementsLength()"(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allTokenHashes(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "allTokenHashes(uint256)"(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allTokenHashesLength(overrides?: CallOverrides): Promise<BigNumber>;

    "allTokenHashesLength()"(overrides?: CallOverrides): Promise<BigNumber>;

    allowPurchase(overrides?: CallOverrides): Promise<BigNumber>;

    "allowPurchase()"(overrides?: CallOverrides): Promise<BigNumber>;

    allowedTokenSources(overrides?: Overrides): Promise<BigNumber>;

    "allowedTokenSources()"(overrides?: Overrides): Promise<BigNumber>;

    allowedTokens(
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "allowedTokens(uint256)"(
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allowedTokensLength(overrides?: CallOverrides): Promise<BigNumber>;

    "allowedTokensLength()"(overrides?: CallOverrides): Promise<BigNumber>;

    category(overrides?: CallOverrides): Promise<BigNumber>;

    "category()"(overrides?: CallOverrides): Promise<BigNumber>;

    claim(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claim(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimAmount(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimAmount(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimQuantity(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimQuantity(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimTokenAmount(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimTokenAmount(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimUnlockTime(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "claimUnlockTime(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimedCount(overrides?: CallOverrides): Promise<BigNumber>;

    "claimedCount()"(overrides?: CallOverrides): Promise<BigNumber>;

    collectClaim(
      claimHash: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "collectClaim(uint256)"(
      claimHash: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    createClaim(
      timeframe: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "createClaim(uint256)"(
      timeframe: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    createClaims(
      timeframe: BigNumberish,
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "createClaims(uint256,uint256)"(
      timeframe: BigNumberish,
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    createERC20Claim(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "createERC20Claim(address,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    createERC20Claims(
      erc20token: string,
      tokenAmount: BigNumberish,
      count: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "createERC20Claims(address,uint256,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      count: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    deposit(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "deposit(address,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    depositNFT(
      erc1155token: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "depositNFT(address,uint256,uint256)"(
      erc1155token: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    description(overrides?: CallOverrides): Promise<BigNumber>;

    "description()"(overrides?: CallOverrides): Promise<BigNumber>;

    enabled(overrides?: CallOverrides): Promise<BigNumber>;

    "enabled()"(overrides?: CallOverrides): Promise<BigNumber>;

    ethPrice(overrides?: CallOverrides): Promise<BigNumber>;

    "ethPrice()"(overrides?: CallOverrides): Promise<BigNumber>;

    gemClaimHash(
      gemHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "gemClaimHash(uint256)"(
      gemHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      __symbol: string,
      __name: string,
      __ethPrice: BigNumberish,
      __minTime: BigNumberish,
      __maxTime: BigNumberish,
      __diffstep: BigNumberish,
      __maxClaims: BigNumberish,
      __allowedToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "initialize(string,string,uint256,uint256,uint256,uint256,uint256,address)"(
      __symbol: string,
      __name: string,
      __ethPrice: BigNumberish,
      __minTime: BigNumberish,
      __maxTime: BigNumberish,
      __diffstep: BigNumberish,
      __maxClaims: BigNumberish,
      __allowedToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    isController(
      caddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isController(address)"(
      caddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTokenAllowed(tkn: string, overrides?: CallOverrides): Promise<BigNumber>;

    "isTokenAllowed(address)"(
      tkn: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    maxClaimsPerAccount(overrides?: CallOverrides): Promise<BigNumber>;

    "maxClaimsPerAccount()"(overrides?: CallOverrides): Promise<BigNumber>;

    maxQuantityPerClaim(overrides?: CallOverrides): Promise<BigNumber>;

    "maxQuantityPerClaim()"(overrides?: CallOverrides): Promise<BigNumber>;

    mintGenesisGems(
      creator: string,
      funder: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "mintGenesisGems(address,address)"(
      creator: string,
      funder: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    mintedCount(overrides?: CallOverrides): Promise<BigNumber>;

    "mintedCount()"(overrides?: CallOverrides): Promise<BigNumber>;

    nextClaimHash(overrides?: CallOverrides): Promise<BigNumber>;

    "nextClaimHash()"(overrides?: CallOverrides): Promise<BigNumber>;

    nextClaimId(overrides?: CallOverrides): Promise<BigNumber>;

    "nextClaimId()"(overrides?: CallOverrides): Promise<BigNumber>;

    nextGemHash(overrides?: CallOverrides): Promise<BigNumber>;

    "nextGemHash()"(overrides?: CallOverrides): Promise<BigNumber>;

    nextGemId(overrides?: CallOverrides): Promise<BigNumber>;

    "nextGemId()"(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    priceIncrementType(overrides?: CallOverrides): Promise<BigNumber>;

    "priceIncrementType()"(overrides?: CallOverrides): Promise<BigNumber>;

    proxies(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "proxies(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    purchaseGems(
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    "purchaseGems(uint256)"(
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    relinquishControl(overrides?: Overrides): Promise<BigNumber>;

    "relinquishControl()"(overrides?: Overrides): Promise<BigNumber>;

    removeAllowedToken(tkn: string, overrides?: Overrides): Promise<BigNumber>;

    "removeAllowedToken(address)"(
      tkn: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removeAllowedTokenSource(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removeAllowedTokenSource(address)"(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setAllowPurchase(allow: boolean, overrides?: Overrides): Promise<BigNumber>;

    "setAllowPurchase(bool)"(
      allow: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setCategory(
      category: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setCategory(uint256)"(
      category: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setDescription(desc: string, overrides?: Overrides): Promise<BigNumber>;

    "setDescription(string)"(
      desc: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setEnabled(enable: boolean, overrides?: Overrides): Promise<BigNumber>;

    "setEnabled(bool)"(
      enable: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setFeeTracker(addr: string, overrides?: Overrides): Promise<BigNumber>;

    "setFeeTracker(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setGovernor(addr: string, overrides?: Overrides): Promise<BigNumber>;

    "setGovernor(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setMaxClaimsPerAccount(
      maxCPA: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setMaxClaimsPerAccount(uint256)"(
      maxCPA: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setMaxQuantityPerClaim(
      maxQty: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setMaxQuantityPerClaim(uint256)"(
      maxQty: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setMultiToken(addr: string, overrides?: Overrides): Promise<BigNumber>;

    "setMultiToken(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setNextIds(
      nextClaimId: BigNumberish,
      nextGemId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setNextIds(uint256,uint256)"(
      nextClaimId: BigNumberish,
      nextGemId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setPriceIncrementType(
      incrementType: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setPriceIncrementType(uint8)"(
      incrementType: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setSwapHelper(addr: string, overrides?: Overrides): Promise<BigNumber>;

    "setSwapHelper(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setToken(
      tokenHash: BigNumberish,
      tokenType: BigNumberish,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setToken(uint256,uint8,uint256)"(
      tokenHash: BigNumberish,
      tokenType: BigNumberish,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setTokenHashes(
      tokenHashes: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setTokenHashes(uint256[])"(
      tokenHashes: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    setValidateErc20(arg0: boolean, overrides?: Overrides): Promise<BigNumber>;

    "setValidateErc20(bool)"(
      arg0: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    setVisible(visible: boolean, overrides?: Overrides): Promise<BigNumber>;

    "setVisible(bool)"(
      visible: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    settings(overrides?: CallOverrides): Promise<BigNumber>;

    "settings()"(overrides?: CallOverrides): Promise<BigNumber>;

    stakedToken(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "stakedToken(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stats(overrides?: CallOverrides): Promise<BigNumber>;

    "stats()"(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "supportsInterface(bytes4)"(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    "symbol()"(overrides?: CallOverrides): Promise<BigNumber>;

    token(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "token(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenHashes(overrides?: CallOverrides): Promise<BigNumber>;

    "tokenHashes()"(overrides?: CallOverrides): Promise<BigNumber>;

    tokenId(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "tokenId(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenType(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "tokenType(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStakedEth(overrides?: CallOverrides): Promise<BigNumber>;

    "totalStakedEth()"(overrides?: CallOverrides): Promise<BigNumber>;

    updateInputRequirement(
      ndx: BigNumberish,
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "updateInputRequirement(uint256,address,address,uint8,uint256,uint256,bool,bool)"(
      ndx: BigNumberish,
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    validateErc20(overrides?: CallOverrides): Promise<BigNumber>;

    "validateErc20()"(overrides?: CallOverrides): Promise<BigNumber>;

    visible(overrides?: CallOverrides): Promise<BigNumber>;

    "visible()"(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      erc20token: string,
      destination: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "withdraw(address,address,uint256)"(
      erc20token: string,
      destination: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    withdrawNFT(
      erc1155token: string,
      destination: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "withdrawNFT(address,address,uint256,uint256)"(
      erc1155token: string,
      destination: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addAllowedToken(
      tkn: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addAllowedToken(address)"(
      tkn: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addAllowedTokenSource(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addAllowedTokenSource(address)"(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addController(
      controller: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addController(address)"(
      controller: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addInputRequirement(
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addInputRequirement(address,address,uint8,uint256,uint256,bool,bool)"(
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addLegacyToken(
      token: string,
      tokenType: BigNumberish,
      tokenHash: BigNumberish,
      tokenId: BigNumberish,
      recipient: string,
      qty: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addLegacyToken(address,uint8,uint256,uint256,address,uint256)"(
      token: string,
      tokenType: BigNumberish,
      tokenHash: BigNumberish,
      tokenId: BigNumberish,
      recipient: string,
      qty: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    allInputRequirements(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "allInputRequirements(uint256)"(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allInputRequirementsLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "allInputRequirementsLength()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allTokenHashes(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "allTokenHashes(uint256)"(
      ndx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allTokenHashesLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "allTokenHashesLength()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allowPurchase(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "allowPurchase()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    allowedTokenSources(overrides?: Overrides): Promise<PopulatedTransaction>;

    "allowedTokenSources()"(
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    allowedTokens(
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "allowedTokens(uint256)"(
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allowedTokensLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "allowedTokensLength()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    category(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "category()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claim(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "claim(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimAmount(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "claimAmount(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimQuantity(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "claimQuantity(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimTokenAmount(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "claimTokenAmount(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimUnlockTime(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "claimUnlockTime(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimedCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "claimedCount()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collectClaim(
      claimHash: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "collectClaim(uint256)"(
      claimHash: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    createClaim(
      timeframe: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "createClaim(uint256)"(
      timeframe: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    createClaims(
      timeframe: BigNumberish,
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "createClaims(uint256,uint256)"(
      timeframe: BigNumberish,
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    createERC20Claim(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "createERC20Claim(address,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    createERC20Claims(
      erc20token: string,
      tokenAmount: BigNumberish,
      count: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "createERC20Claims(address,uint256,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      count: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    deposit(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "deposit(address,uint256)"(
      erc20token: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    depositNFT(
      erc1155token: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "depositNFT(address,uint256,uint256)"(
      erc1155token: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    description(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "description()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    enabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "enabled()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ethPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "ethPrice()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gemClaimHash(
      gemHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "gemClaimHash(uint256)"(
      gemHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      __symbol: string,
      __name: string,
      __ethPrice: BigNumberish,
      __minTime: BigNumberish,
      __maxTime: BigNumberish,
      __diffstep: BigNumberish,
      __maxClaims: BigNumberish,
      __allowedToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "initialize(string,string,uint256,uint256,uint256,uint256,uint256,address)"(
      __symbol: string,
      __name: string,
      __ethPrice: BigNumberish,
      __minTime: BigNumberish,
      __maxTime: BigNumberish,
      __diffstep: BigNumberish,
      __maxClaims: BigNumberish,
      __allowedToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    isController(
      caddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isController(address)"(
      caddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTokenAllowed(
      tkn: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isTokenAllowed(address)"(
      tkn: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxClaimsPerAccount(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "maxClaimsPerAccount()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxQuantityPerClaim(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "maxQuantityPerClaim()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mintGenesisGems(
      creator: string,
      funder: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "mintGenesisGems(address,address)"(
      creator: string,
      funder: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    mintedCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "mintedCount()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextClaimHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "nextClaimHash()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextClaimId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "nextClaimId()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextGemHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "nextGemHash()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextGemId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "nextGemId()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    onERC1155BatchReceived(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    onERC1155Received(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "onERC1155Received(address,address,uint256,uint256,bytes)"(
      arg0: string,
      arg1: string,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    priceIncrementType(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "priceIncrementType()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proxies(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "proxies(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    purchaseGems(
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    "purchaseGems(uint256)"(
      count: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    relinquishControl(overrides?: Overrides): Promise<PopulatedTransaction>;

    "relinquishControl()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    removeAllowedToken(
      tkn: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeAllowedToken(address)"(
      tkn: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removeAllowedTokenSource(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeAllowedTokenSource(address)"(
      allowedToken: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setAllowPurchase(
      allow: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setAllowPurchase(bool)"(
      allow: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setCategory(
      category: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setCategory(uint256)"(
      category: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setDescription(
      desc: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setDescription(string)"(
      desc: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setEnabled(
      enable: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setEnabled(bool)"(
      enable: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setFeeTracker(
      addr: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setFeeTracker(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setGovernor(
      addr: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setGovernor(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setMaxClaimsPerAccount(
      maxCPA: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setMaxClaimsPerAccount(uint256)"(
      maxCPA: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setMaxQuantityPerClaim(
      maxQty: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setMaxQuantityPerClaim(uint256)"(
      maxQty: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setMultiToken(
      addr: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setMultiToken(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setNextIds(
      nextClaimId: BigNumberish,
      nextGemId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setNextIds(uint256,uint256)"(
      nextClaimId: BigNumberish,
      nextGemId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setPriceIncrementType(
      incrementType: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setPriceIncrementType(uint8)"(
      incrementType: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setSwapHelper(
      addr: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setSwapHelper(address)"(
      addr: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setToken(
      tokenHash: BigNumberish,
      tokenType: BigNumberish,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setToken(uint256,uint8,uint256)"(
      tokenHash: BigNumberish,
      tokenType: BigNumberish,
      tokenId: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setTokenHashes(
      tokenHashes: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setTokenHashes(uint256[])"(
      tokenHashes: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setValidateErc20(
      arg0: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setValidateErc20(bool)"(
      arg0: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    setVisible(
      visible: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setVisible(bool)"(
      visible: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    settings(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "settings()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakedToken(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "stakedToken(uint256)"(
      claimHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    stats(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "stats()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "supportsInterface(bytes4)"(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "symbol()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    token(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "token(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenHashes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "tokenHashes()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenId(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "tokenId(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenType(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "tokenType(uint256)"(
      tokenHash: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalStakedEth(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "totalStakedEth()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    updateInputRequirement(
      ndx: BigNumberish,
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "updateInputRequirement(uint256,address,address,uint8,uint256,uint256,bool,bool)"(
      ndx: BigNumberish,
      token: string,
      pool: string,
      inputType: BigNumberish,
      tid: BigNumberish,
      minAmount: BigNumberish,
      takeCustody: boolean,
      burn: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    validateErc20(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "validateErc20()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    visible(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "visible()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      erc20token: string,
      destination: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "withdraw(address,address,uint256)"(
      erc20token: string,
      destination: string,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    withdrawNFT(
      erc1155token: string,
      destination: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "withdrawNFT(address,address,uint256,uint256)"(
      erc1155token: string,
      destination: string,
      tokenId: BigNumberish,
      tokenAmount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
