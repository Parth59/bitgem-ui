# Bitgem UI

This is the UI for the https://bitgem.co site. This site is built using React, NextJS and TailwindCSS

## Initial setup

To setup the project, first run `yarn install`

Generate typescript bindings from graphql schema and operations: `yarn codegen` (you need to be running a local graph node with the version you want to be testing or point codegen.yml to the server that has it.

if you want to be able to deploy a staging server, you'll need to install vercel by running `npm i -g vercel` and create an account.

## Develop

To run a local dev server, after cloning the repository run:

- yarn dev
- Navigate to https://localhost:3000

To fully run locally, you need to be running a local graph node (nftgem/subgraph) and a local network (nftgem-contracts).

## Deploy

To deploy a staging server:

- vercel

To deploy to production:

- vercel --prod

## Notes

Data flow:

* Designed a data flow that accounts for certain challenges of the services we use. Mainly:
  * The single source of truth for the data we display comes from thegraph.
  * Thegraph is indexed from mapping functions that are triggered from contract events. This means there’s a delta of time between contract events firing and the data being available to be pulled from the graph.
  * Thegraph subscriptions are not  stable, so we can’t count of those to keep our data fresh.
  * In general, we can’t rely on contract-related methods (like transaction.wait() results) to know when there’s fresh data to pull.
* The solution implemented is based on polling the graphql server (this is what thegraph devs recommend). see below for section on QueryManagerContext.
  * We maintain a pending cache with data that we’ve submitted to the blockchain (like a claim when one was submitted or a gem one a claim was collected) but before the result is available from thegraph.
  * We use hooks that merge the pending cache with the server cache to display our lists with optimistic updates.
  * We poll the server while there are pending items and clear the pending items when they have been indexed by thegraph.
* As we go we can identify places where we can decrease prevent excessive polling using these methods:
  * tell react-query not to poll when the browser window is in the background.
  * manually decrease polling intervals.
  * we already do not poll certain queries unless we know we are waiting for data (like a claim that was submitted)

Server cache and query manager:

* ```
  QueryManagerContext maintains a list of gql queries and polls at a given interval.
  ```
* The interval at which each query is polled can be set in two ways by users of the manager:
* imperatively, you an consume the context provided, it contains dispatch methods to set the intervals. Setting the interval this way will affect the polling interval from that moment forward independently of any component lifecycle.

```
const {setClaimRefetchInterval} = useQueryManager();
setClaimRefetchInterval(5000);  // claims will be polled every 5 seconds.
```

```
* Preferred use is to control this declaratively, you can use the useClaimQueryRefetchInterval hook in any given component, during the life of the component, the query will be polled at the interval given, once the component unmount, the poll interval will go back to what it was previously.
* Usage example: while on the pools page, we use the useClaimQueryRefetchInterval to poll thegraph very frequently, this updates the pool prices as they go up, once the user navigates away from that page, the query interval goes back to its previous setting.
```

* Query manager uses react-query to manage the server cache and uses fetching functions generated by graphql-codegen using a graphql-request fetcher.
* You can find/add new graphql queries under /graph. Add a query to operations.graphql and then run `yarn cogegen` to generate the typescript bindings and react-query hooks.
  Web3ReactManager
* Handles the network connection, eagerly connects to approved wallets and reconnects when there are issues.
* Still need to work on the UX for edge cases around connection issues.
* you can add new networks under /lib/connectors.ts and /lib/network-connector.ts
* Code for multi-networks is based on sushiswap

Web3Events

* There are three contract event based hooks:
* useWeb3Event(contract, eventId, eventHandler): while the component is mounted, trigger eventHandler when eventId on contract fires.
* useWeb3Notification(contract, eventId, message): displays a toast message when a contract event fires.
* useCacheInvalidationOnEvent(contract, eventId, queryKey): might need this at some point, it invalidates the cache for all queries that match the given queryKey, triggering a refetch if any of them are currently mounted or being polled.

